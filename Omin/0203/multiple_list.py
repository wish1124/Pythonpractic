# 문제 1: 구구단 표 만들기
# 문제 설명:
# 5행 5열의 이중 리스트를 만들어서, 각 원소에 해당하는 위치의 행과 열의 곱(예, i×j)을 저장하는 구구단 표를 만들어 보세요. (행과 열의 인덱스는 1부터 시작한다고 가정합니다.)
# 예시 출력 (5×5):

# 복사 i행 j열 
# 1  2  3  4  5
# 2  4  6  8 10
# 3  6  9 12 15
# 4  8 12 16 20
# 5 10 15 20 25
# Hint

# 이중 리스트를 생성하는 여러 가지 방법(list comprehension 등)을 사용해 보세요.
# 출력 시 정렬(format)을 사용하여 보기 좋게 만들어 보세요.




# 문제 2: 전치 행렬 구하기
# 문제 설명:
# 주어진 2차원 리스트(행렬)의 전치(transpose)를 구하는 함수를 작성하세요.
# 예시 입력:

# python
# 복사
# matrix = [
#     [1, 2, 3],
#     [4, 5, 6]
# ]
# 예시 출력:
# 전치 행렬은 다음과 같아야 합니다.

# python
# 복사
# [
#     [1, 4],
#     [2, 5],
#     [3, 6]
# ]
# 도전 포인트:

# for문, list comprehension 또는 zip 함수를 활용하여 전치 행렬을 구하는 다양한 방법을 시도해 보세요.
# 입력 행렬의 행/열 수가 달라도 일반화된 코드로 작성해 보세요.



#answer[i][j] = matrix[j][i]

matrix = [
    [1, 2, 3],
    [4, 5, 6]
]

answer = [ [0, 100], [93, 21], [-1,71] ]


# print(len(answer)) #3

# print(len(answer[0])) #2

for i in range(len(answer)): # i = 0, 1, 2
  for j in range(len(answer[0])): # j = 0, 1 range(2)
    answer[i][j] = matrix[j][i]
    





# 문제 3: 이중 리스트에서 특정 요소 찾기
# 문제 설명:
# 이중 리스트(행렬)와 검색할 값을 입력받아, 해당 값이 나타나는 모든 위치(행, 열 인덱스)를 리스트 형태로 반환하는 함수를 작성하세요. 만약 값이 없으면 빈 리스트를 반환합니다.
# 예시 입력:

# python

matrix = [
    [3, 5, 1],
    [2, 5, 9],
    [5, 0, 4]
]
target = 5
# 예시 출력:

answer = []


for i in range(len(matrix)):
  for j in range(len(matrix[0])):
    x = matrix[i][j]
    if x == target:
      answer.append((i, j))

print(answer)






matrix = [
    [[1,2], [3,4], [5,6]],
    [[7,8], [9,10], [11,12]],
    [[13,14], [15,16], [17,18]]
]

# list shape : 3 x 3 x 2 3중 리스트

for i in range(len(matrix)): # 0, 1, 2
    for j in range(len(matrix[0])): # 0, 1, 2
      for k in range(len(matrix[0][0])): # 0, 1
        print(matrix[i][j][k], end=' ')
      print(" ")
      


# 도전 포인트:

# 이중 for문을 사용하여 모든 원소를 순회하며 인덱스를 기록해 보세요.
# 리스트의 인덱스와 enumerate 함수를 활용하여 더 간결하게 작성해 보세요.


# 조금 더 난이도 있는 문제
# 문제 4: 미로 탈출 (최단 경로 찾기)
# 문제 설명:
# 𝑁
# ×
# 𝑀
# N×M 크기의 미로가 주어집니다. 이 미로는 2차원 리스트로 표현되며,

# 0: 이동 가능한 경로
# 1: 벽(이동 불가능)
# 을 나타냅니다. 시작 위치는 (0, 0)이고, 미로의 출구는 (N-1, M-1)입니다. 이 때, 출구까지 가기 위한 최단 경로의 길이를 반환하는 함수를 작성하세요. 경로가 존재하지 않는다면 -1을 반환합니다.
# 예시 입력:

# python

# maze = [
#     [0, 1, 0, 0, 0],
#     [0, 1, 0, 1, 0],
#     [0, 0, 0, 1, 0],
#     [1, 1, 0, 1, 0],
#     [0, 0, 0, 0, 0]
# ]
# 예시 출력:
# 9
# (위 미로에서 최단 경로의 길이는 9임)

# 도전 포인트:

# **BFS (너비 우선 탐색)**를 활용하여 최단 경로 문제를 해결해 보세요.
# 좌표 처리를 위해 tuple이나 collections.deque 등의 자료구조를 사용해 보세요.
# 미로의 크기가 임의로 커질 수 있으므로, 시간 복잡도를 고려한 효율적인 코드를 작성해 보세요.
# 경로를 찾는 것뿐만 아니라, 실제 경로(예: 좌표 리스트)를 반환하도록 확장해 볼 수도 있습니다.
# 힌트:

# 시작 지점 (0,0)부터 시작하여 각 단계마다 상하좌우로 이동 가능한 위치를 확인하세요.
# 이미 방문한 위치는 재방문하지 않도록 관리합니다.
# 각 위치에 도달하는 데 걸린 이동 횟수를 기록하면서, 목표 지점에 도달하면 이동 횟수를 반환하면 됩니다.